{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Home","text":""},{"location":"#welcome-to-fleetingviews","title":"Welcome to FleetingViews \ud83d\udc4b","text":"<p>FleetingViews is a lightweight but powerful utility class that simplifies view management in Flet applications. Inspired by modern frontend routing systems, FleetingViews provides tools to create, switch, animate, and control views with ease\u2014no boilerplate, no fuss.</p>"},{"location":"#features-v018","title":"\u2728 Features (v0.1.8)","text":"<ul> <li>\ud83d\ude80 Easy view declaration and dynamic navigation</li> <li>\ud83e\udded Built-in navigation history with <code>go_back()</code></li> <li>\ud83e\uddf1 Add controls dynamically from views</li> <li>\ud83c\udfad Animated transitions between views</li> <li>\ud83e\udde9 Lifecycle hooks (<code>on_mount</code>, <code>on_dismount</code>, <code>on_view_change</code>)</li> <li>\ud83d\udee1\ufe0f Guard functions to protect certain views</li> <li>\ud83e\uddc3 Support for drawers, FABs, AppBars.</li> <li>\ud83e\udde9 Easy to modularize view definitions and logic</li> <li>\ud83c\udf10 Easily pass and handle query parameters in views with FleetingViews</li> <li>\ud83d\udd04 Seamlessly share data across views and components with FleetingViews</li> </ul> <p>\u2728 Features (v0.2)</p> <pre><code>\u26a1 Reactive Observables with define_observable() and subscribe()\n\n\ud83d\udd01 Two-Way Data Binding with bind_to_control()\nEasily sync TextField, Dropdown, and similar inputs with shared state\n\n\ud83d\udd02 unsubscribe() and unbind_control() to fully detach views or handlers\n\n\ud83e\udde0 Mix UI and logic: auto-update controls, trigger functions, or both\n\n\ud83e\uddea Clean reactive flow: write once, update everywhere\n\n\ud83d\udd27 Prepares ground for computed values, watchers, and persistence (coming soon)\n</code></pre>"},{"location":"#installation","title":"\ud83d\udce6 Installation","text":"<pre><code>pip install fleetingviews\n</code></pre>"},{"location":"#why-fleetingviews","title":"\u2753 Why FleetingViews?","text":"<p>Managing multiple views in a Flet app can quickly get messy. FleetingViews helps you:</p> <ul> <li>\ud83e\uddf9 Organize your views declaratively</li> <li>\ud83d\udd04 Handle transitions and user navigation easily</li> <li>\ud83e\udde0 Inject custom behavior with guards and hooks</li> <li>\ud83e\uddd1\u200d\ud83d\udcbb Focus on your app logic, not view plumbing</li> </ul> <p>\u201cWith FleetingViews, you think about what your app does not how to juggle UI blocks.\u201d</p>"},{"location":"#repository","title":"Repository","text":""},{"location":"404_page/","title":"FleetingViews - Custom 404 Page Handling","text":""},{"location":"404_page/#missing-page-handling-404","title":"Missing Page Handling (404)","text":"<p>FleetingViews now gracefully handles missing pages by redirecting users to a fallback 404 page that you can configure. When a user attempts to navigate to a page that doesn't exist, FleetingViews automatically redirects to a 404 view.</p>"},{"location":"404_page/#default-behavior","title":"Default Behavior","text":"<p>If you try to navigate to a view that doesn\u2019t exist, FleetingViews will automatically redirect to the <code>404_not_found</code> view, showing a standard error message and a button to return to the root view:</p> <pre><code>fv.view_go(\"non_existent_page\")\n</code></pre>"},{"location":"404_page/#missing-page-handling-404_1","title":"Missing Page Handling (404)","text":"<p>You can fully customize the <code>404_not_found</code> view just like any other view. Here's an example of how to configure a 404 page with a message and a button to go back to the home page.</p> <p>Example of 404 View Definition</p> <pre><code>view_definitions = {\n    'home': {\n        'bgcolor': ft.Colors.BLUE_GREY,\n        'vertical_alignment': ft.MainAxisAlignment.CENTER,\n        'horizontal_alignment': ft.CrossAxisAlignment.CENTER,\n        \"appbar\": appbar,\n    },\n    # Customization of the 404 View\n    '404_not_found': {\n        'bgcolor': ft.Colors.RED_300,\n        'vertical_alignment': ft.MainAxisAlignment.CENTER,\n        'horizontal_alignment': ft.CrossAxisAlignment.CENTER,\n        \"controls\": [\n            ft.Text(\"Oops! This page doesn't exist (404)\", size=30, weight=\"bold\", color=ft.Colors.BLACK),\n            ft.Text(\"Please check the URL or go back to a known view.\", color=ft.Colors.BLACK),\n            ft.ElevatedButton(\"Go to Home\", on_click=lambda e: fv.view_go(\"home\"))\n        ],\n        \"appbar\": appbar,\n    },\n}\n</code></pre> <p>Creating the Views When creating the views, you can enable or disable the missing page handler with the fallback_404 parameter. If enabled, FleetingViews will automatically redirect to the <code>404_not_found</code> view when trying to access a non-existing page:</p> <pre><code>fv = fleetingviews.create_views(view_definitions=view_definitions, page=page) #Fallback is true by default\n</code></pre> <p>If you prefer to disable the automatic 404 handling, simply set <code>fallback_404=False</code>:</p> <pre><code>fv = fleetingviews.create_views(view_definitions=view_definitions, page=page, fallback_404=False)\n</code></pre>"},{"location":"404_page/#important-note","title":"Important Note","text":"<p>If you disable the automatic 404 handler, attempting to navigate to a non-existent view will raise a <code>ValueError</code>:</p> <pre><code>ValueError(f\"{name} is not a view of this FleetingViews\")\n</code></pre> <p>This ensures you are aware that the requested view is not valid.</p> <p>This way, you can fully control how missing pages are handled in your application.</p>"},{"location":"Hooks_and_guards/","title":"\ud83d\udd12 Hooks &amp; Guards in FleetingViews (v0.1.8)","text":"<p>FleetingViews supports lifecycle hooks and navigation guards to help you manage your view's logic more dynamically and safely.</p>"},{"location":"Hooks_and_guards/#lifecycle-hooks","title":"\ud83e\ude9d Lifecycle Hooks","text":"<p>You can attach functions to specific views that run when the view is mounted or dismounted. These functions are useful for initializing resources, fetching data, or cleaning up when navigating between views.</p>"},{"location":"Hooks_and_guards/#supported-hooks","title":"Supported Hooks:","text":"<ul> <li><code>on_mount</code>: Runs when the view is shown.</li> <li><code>on_dismount</code>: Runs just before the view is hidden.</li> </ul> <p>Each of these can accept a single function or a list of functions, and will be executed in the order provided.</p>"},{"location":"Hooks_and_guards/#example","title":"Example","text":"<pre><code>def fetch_user_data(ctx):\n    print(\"Fetching user data...\")\n\ndef save_changes(ctx):\n    print(\"Saving form changes...\")\n\nfv.add_hooks_or_guards(\"profile\", {\n    \"on_mount\": fetch_user_data,\n    \"on_dismount\": save_changes,\n})\n</code></pre> <p>You can also pass multiple functions:</p> <pre><code>fv.add_hooks_or_guards(\"profile\", {\n    \"on_mount\": [func_a, func_b],\n    \"on_dismount\": [cleanup1, cleanup2],\n})\n</code></pre> <p>You can also define hooks directly inside your <code>view_definitions</code>:</p> <pre><code>def my_on_mount_hook(ctx):\n    print(f\"Hello page {ctx.actual_view.route} {ctx._query_params}\")\n# View definitions with specific configurations\nview_definitions = {\n    \"home\": {\n        \"bgcolor\": ft.colors.BLUE_GREY,\n        \"vertical_alignment\": ft.MainAxisAlignment.CENTER,\n        \"horizontal_alignment\": ft.CrossAxisAlignment.CENTER,\n        \"on_mount\": my_on_mount_hook\n    },\n    \"settings\": {\n        \"bgcolor\": ft.colors.AMBER_900,\n        \"vertical_alignment\": ft.MainAxisAlignment.CENTER,\n        \"horizontal_alignment\": ft.CrossAxisAlignment.CENTER,\n    }\n\n}\n</code></pre>"},{"location":"Hooks_and_guards/#notes","title":"Notes","text":"<ul> <li>It is advised that the hooks are given a context argument to get useful information in the manager ex: <code>ctx.get_param(\"param_name\", default)</code> will give you the parameter, you can also use <code>ctx.get_params()</code>.</li> <li>You can't create hooks that receive more than <code>ctx</code>.</li> </ul>"},{"location":"Hooks_and_guards/#on_view_change-hook","title":"<code>on_view_change</code> Hook","text":"<p>You can now define an <code>on_view_change</code> callback that gets executed every time the active view changes, regardless of where the navigation came from.</p> <p>This is useful for analytics, layout adjustments, logging, or global effects when the view changes.</p> <p>\u26a0\ufe0f For maintainability reasons, only one <code>on_view_change</code> handler is allowed. It should be a single callable function.</p> <p><code>on_view_change</code> must accept exactly two arguments: <code>view_name</code> and <code>params</code></p> <p>Example:</p> <pre><code>def my_global_view_change_handler(view_name: str, params):\n    print(f\"Changed to view: {view_name} with params: {params}\")\n\nfv.on_view_change = my_global_view_change_handler\n</code></pre>"},{"location":"Hooks_and_guards/#navigation-guards","title":"\ud83d\udee1\ufe0f Navigation Guards","text":"<p>Guards are functions that run before changing to a specific view. They determine whether or not the view transition should happen.</p> <p>Each guard function must return <code>True</code> or <code>False</code>:</p> <p>Return <code>True</code> to allow navigation.</p> <p>Return <code>False</code> to prevent the view from being shown.</p> <p>This is useful for authentication checks, permission validation, or confirming unsaved changes.</p>"},{"location":"Hooks_and_guards/#important","title":"Important","text":"<ul> <li>\u26a0\ufe0f If any of the guards return a <code>False</code>, the navigation is stopped and no hooks or events will be triggered.</li> <li>All guards must accept exactly two arguments: <code>ctx</code> and <code>name</code>.. <code>ctx</code> will be the <code>FleetingViews</code> manager and <code>name</code> the name of the view thats being evaluated.</li> </ul>"},{"location":"Hooks_and_guards/#example_1","title":"Example","text":"<pre><code>def is_user_logged_in(ctx, name):\n    # Only allow access if the user is logged in\n    return session.get(\"logged_in\", False)\n\nfv.add_hooks_or_guards(\"dashboard\", {\n    \"guards\": is_user_logged_in\n})\n</code></pre> <p>As with hooks, you can add a list of them or define them in the <code>view_definitions</code>:</p> <pre><code>def is_user_logged_in(ctx, name):\n        # Only allow access if the user is logged in\n    return session.get(\"logged_in\", False)\n\n# View definitions with specific configurations\nview_definitions = {\n    \"home\": {\n        \"bgcolor\": ft.colors.BLUE_GREY,\n        \"vertical_alignment\": ft.MainAxisAlignment.CENTER,\n        \"horizontal_alignment\": ft.CrossAxisAlignment.CENTER,\n        \"guards\": is_user_logged_in\n    },\n    \"settings\": {\n        \"bgcolor\": ft.colors.AMBER_900,\n        \"vertical_alignment\": ft.MainAxisAlignment.CENTER,\n        \"horizontal_alignment\": ft.CrossAxisAlignment.CENTER,\n    }\n\n}\n</code></pre>"},{"location":"Hooks_and_guards/#removing-hooks-or-guards-v019","title":"Removing hooks or guards (v0.1.9)","text":"<p>FleetingViews also permits you to remove hooks or guards during execution. In a very similar way as to how you'd add them:</p> <pre><code>def is_user_logged_in(ctx, name):\n    # Only allow access if the user is logged in\n    return session.get(\"logged_in\", False)\n\n# Remove a single guard from a view\nfv.remove_hooks_or_guards(\"dashboard\", {\n    \"guards\": is_user_logged_in\n})\n\n# Or multiple at once\nfv.remove_hooks_or_guards(\"dashboard\", {\n    \"guards\": [is_user_logged_in, other_function]\n})\n</code></pre>"},{"location":"Hooks_and_guards/#full-lifecycle","title":"Full Lifecycle","text":"<p>Navigation attempt -&gt; Run Guards -&gt; [All True?] -&gt; Run on_dismounts -&gt; Change View -&gt; Run on_mounts -&gt; Run on_view_change</p>"},{"location":"animations/","title":"Animations","text":""},{"location":"animations/#availible-from-v012","title":"Availible from V0.1.2","text":"<p>This version of FleetingViews now enables view transitions with customizable position and duration for every <code>view_go()</code> and <code>go_back()</code> call.</p> <p>For example, let's initialize some views in our project:</p> <pre><code># View definitions with specific configurations\nview_definitions = {\n        'home': {\n            'bgcolor': ft.colors.RED,\n            'vertical_alignment': ft.MainAxisAlignment.CENTER,\n            'horizontal_alignment': ft.CrossAxisAlignment.CENTER\n        },\n        'projects': {\n            'bgcolor': ft.colors.PURPLE,\n        }\n    }\n\nfv = fleetingviews.create_views(view_definitions=view_definitions, page=page)\n</code></pre> <p>Now, all that is left is to call one of the methods as follows:</p> <pre><code># Navigate to the \"projects\" view with a 300ms animation from the right\nfv.view_go(\"projects\", duration=300, mode=\"right\")\n</code></pre> <p>By adding the duration parameter with a value above 0, FleetingViews will know that the call is intended to have an animation that lasts <code>duration</code> milliseconds.</p> <p>You can also declare the animation mode that you prefer from the options below:</p>"},{"location":"animations/#1-top_left-default","title":"1. top_left (default)","text":""},{"location":"animations/#2-top","title":"2. top","text":""},{"location":"animations/#3-top_right","title":"3. top_right","text":""},{"location":"animations/#4-right","title":"4. right","text":""},{"location":"animations/#5-bottom_right","title":"5. bottom_right","text":""},{"location":"animations/#6-bottom","title":"6. bottom","text":""},{"location":"animations/#7-bottom_left","title":"7. bottom_left","text":""},{"location":"animations/#8-left","title":"8. left","text":"<pre><code>#For example\nfv.view_go(\"projects\", duration=300, mode=\"right\")\n</code></pre>"},{"location":"features/","title":"Features","text":""},{"location":"features/#v010","title":"V(0.1.0)","text":""},{"location":"features/#1-automatic-view-creation-with-customized-design","title":"1. Automatic View Creation with Customized Design:","text":"<p>Quickly create views with specified settings, including background colors, alignments, and other attributes.</p>"},{"location":"features/#2-view-history-for-back-calls","title":"2. View History for \"Back\" Calls:","text":"<p>Navigate back to previous views effortlessly, enhancing the user experience.</p>"},{"location":"features/#3-custom-append-methods","title":"3. Custom Append Methods:","text":"<p>Easily add controls to specific views with custom appends methods.</p>"},{"location":"features/#4-clear-method","title":"4. Clear Method:","text":"<p>Reset the view history with a simple clear method.</p>"},{"location":"features/#v012","title":"V(0.1.2)","text":""},{"location":"features/#view-change-custom-animations","title":"View Change Custom Animations!","text":"<p>Easily add transitions for any <code>view_go()</code> call with custom duration and modes.</p>"},{"location":"features/#customizable-pageupdate-calls-for-page-building-in-the-background","title":"Customizable <code>page.update()</code> Calls for Page Building in the Background","text":"<p>Now you are able to add controls in the \"background\" without updating the page by setting update=False on <code>wadd()</code> and <code>append()</code> methods.</p>"},{"location":"features/#v018","title":"V(0.1.8)","text":""},{"location":"features/#1-query-parameters-for-dynamic-views","title":"1. Query Parameters for Dynamic Views!","text":"<p>Easily pass and retrieve query parameters in your views using <code>get_param(\"param_name\", \"Default if not existent\")</code> or <code>get_params()</code>. Customize views based on URL parameters for a more dynamic user experience. \ud83e\udde9 Example: <pre><code># Retrieve a query parameter\nparam = fv.get_param(\"param_name\", default_value)\n\n#Retrieve all parameters\nparams = fv.get_params()\n</code></pre></p>"},{"location":"features/#2-shared-data-between-views","title":"2. Shared Data Between Views!","text":"<p>Share data across multiple views with a single FleetingViews instance. The shared data object can hold any values or objects that need to persist between views. Example: <pre><code># Set shared data\nfv.set_shared(\"user_info\", {\"name\": \"John\", \"age\": 30})\n\n# Retrieve shared data in a different view\nuser_info = fv.get_shared(\"user_info\", default_value)\n</code></pre></p>"},{"location":"features/#3-enhanced-view-navigation-with-url-parameters","title":"3. Enhanced View Navigation with URL Parameters!","text":"<p>The <code>view_go()</code> method now supports URL parameters, making it easier to navigate to views with specific configurations or user data embedded in the URL. Example: <pre><code>fv.view_go(\"settings?theme=dark&amp;lang=en\")\n</code></pre></p>"},{"location":"features/#4-improved-go_back-handling-with-parameters","title":"4. Improved <code>go_back()</code> Handling with Parameters!","text":"<p>The <code>go_back()</code> method now remembers not only the view but also any query parameters, making it easier to return to a specific state in your application.</p>"},{"location":"features/#5-added-lifecycle-hooks","title":"5. Added Lifecycle Hooks!","text":"<p>FleetingViews now supports lifecycle hooks, allowing you to add custom behavior when views are mounted or unmounted. Use <code>on_mount</code> and <code>on_dismount</code> hooks to manage side effects such as fetching data, setting states, or cleaning up resources when switching between views. Example:</p> <p>You can do it in the very definitions of your views: <pre><code>def my_on_mount_hook(ctx):\n    print(f\"Hello page {ctx.actual_view.route} {ctx._query_params}\")\n# View definitions with specific configurations\nview_definitions = {\n    \"home\": {\n        \"bgcolor\": ft.colors.BLUE_GREY,\n        \"vertical_alignment\": ft.MainAxisAlignment.CENTER,\n        \"horizontal_alignment\": ft.CrossAxisAlignment.CENTER,\n        \"on_mount\": my_on_mount_hook\n    },\n    \"settings\": {\n        \"bgcolor\": ft.colors.AMBER_900,\n        \"vertical_alignment\": ft.MainAxisAlignment.CENTER,\n        \"horizontal_alignment\": ft.CrossAxisAlignment.CENTER,\n    }\n\n}\n</code></pre> Or you can add more callables during execution!. <pre><code>def my_on_mount_hook(ctx):\n    print(f\"Hello page {ctx.actual_view.route} {ctx._query_params}\")\n# View definitions with specific configurations\nview_definitions = {\n    \"home\": {\n        \"bgcolor\": ft.colors.BLUE_GREY,\n        \"vertical_alignment\": ft.MainAxisAlignment.CENTER,\n        \"horizontal_alignment\": ft.CrossAxisAlignment.CENTER,\n    },\n    \"settings\": {\n        \"bgcolor\": ft.colors.AMBER_900,\n        \"vertical_alignment\": ft.MainAxisAlignment.CENTER,\n        \"horizontal_alignment\": ft.CrossAxisAlignment.CENTER,\n    }\n\n}\n\nfv = fleetingViews.create_views(view_definitions=view_definitions, page=page)\n\nfv.add_hooks_or_guards(\"home\", {\"on_mount\": my_on_mount_hook})\n</code></pre></p>"},{"location":"features/#notes","title":"Notes","text":"<ul> <li>You can use <code>fv.add_hooks_or_guards()</code> to attach one or multiple callables to a view\u2019s <code>on_mount</code>, <code>on_dismount</code>, or <code>guards</code> lifecycle events. Check the full documentation for usage examples and more details!</li> </ul>"},{"location":"features/#6-missing-page-handling","title":"6. Missing Page Handling!","text":"<p>When navigating to a view that doesn\u2019t exist, FleetingViews now handles missing pages gracefully by redirecting users to a fallback page you configure. <pre><code>fv.view_go(\"non_existent_page\")\n</code></pre></p> <p>By default, this will automatically redirect to the special \"404_not_found\" view, which comes with a default error message (similar to common hosting platforms) and a button that sends the user back to the root view.</p> <p>This handler is always created unless explicitly disabled: <pre><code> fv = fleetingViews.create_views(view_definitions=view_definitions, \n                                page=page, \n                                fallback_404=False)\n</code></pre></p> <p>Of course, you can fully customize the \"404_not_found\" page just like any other view: <pre><code>view_definitions = {\n    'home': {\n        'bgcolor': ft.Colors.BLUE_GREY,\n        'vertical_alignment': ft.MainAxisAlignment.CENTER,\n        'horizontal_alignment': ft.CrossAxisAlignment.CENTER,\n        \"appbar\": appbar,\n        \"on_mount\": my_on_mount_hook\n    },\n    ###EDITION OF NOT FOUND VIEW\n    '404_not_found': {\n        'bgcolor': ft.Colors.RED_300,\n        'vertical_alignment': ft.MainAxisAlignment.CENTER,\n        'horizontal_alignment': ft.CrossAxisAlignment.CENTER,\n        \"controls\": [ft.Text(\"Oops! This page doesn't exist (404)\", \n                        size=30, \n                        weight=\"bold\", \n                        color=ft.Colors.BLACK),\n            ft.Text(\"Please check the URL or go back to a known view.\",\n                    color=ft.Colors.BLACK)],\n        \"appbar\": appbar,\n    },\n}\n</code></pre></p>"},{"location":"features/#7-added-on_view_change-handler","title":"7. Added <code>on_view_change</code> handler","text":"<p>You can now define an <code>on_view_change</code> callback that gets executed every time the active view changes, regardless of where the navigation came from.</p> <p>This is useful for analytics, layout adjustments, logging, or global effects when the view changes.</p> <p>\u26a0\ufe0f For maintainability reasons, only one <code>on_view_change</code> handler is allowed. It should be a single callable function.</p> <p>Example:</p> <pre><code>def my_global_view_change_handler(view_name: str, params):\n    print(f\"Changed to view: {view_name} with params: {params}\")\n\nfv.on_view_change = my_global_view_change_handler\n</code></pre>"},{"location":"getting-started/","title":"Getting Started","text":""},{"location":"getting-started/#installation","title":"Installation","text":"<p>To install FleetingViews, run <pre><code>pip install fleetingviews\n</code></pre> To upgrade to the latest version:</p> <pre><code>pip install fleetingviews --upgrade\n</code></pre>"},{"location":"getting-started/#import","title":"Import","text":"<pre><code>import FleetingViews as fleetingviews\n</code></pre>"},{"location":"getting-started/#defining-your-views","title":"Defining Your Views","text":"<p>Start by defining your views using a simple dictionary structure. Each key is a view name, and its value is a dictionary of view-specific configurations.</p> <pre><code># View definitions with specific configurations\nview_definitions = {\n    \"home\": {\n        \"bgcolor\": ft.colors.BLUE_GREY,\n        \"vertical_alignment\": ft.MainAxisAlignment.CENTER,\n        \"horizontal_alignment\": ft.CrossAxisAlignment.CENTER,\n    },\n    \"settings\": {\n        \"bgcolor\": ft.colors.AMBER_900,\n        \"vertical_alignment\": ft.MainAxisAlignment.CENTER,\n        \"horizontal_alignment\": ft.CrossAxisAlignment.CENTER,\n    },\n    \"projects\": {\n        \"bgcolor\": ft.colors.BLACK,\n        \"vertical_alignment\": ft.MainAxisAlignment.CENTER,\n        \"horizontal_alignment\": ft.CrossAxisAlignment.CENTER,\n    },\n}\n</code></pre>"},{"location":"getting-started/#notes","title":"Notes","text":"<ul> <li>This is the most basic example. We'll cover more advanced definitions later on.</li> <li>Any omitted argument will fall back to Flet\u2019s default values.</li> <li>You can declare views in any order, but the first one will be treated as the root view (i.e., the default entry point of your app).</li> </ul>"},{"location":"getting-started/#initializing-fleetingviews","title":"Initializing FleetingViews","text":"<p>Once you\u2019ve defined your views, create a FleetingViews object: <pre><code>fv = fleetingviews.create_views(view_definitions=view_definitions, page=page)\n</code></pre> That\u2019s it! One line of code and your views are ready.</p>"},{"location":"getting-started/#navigating-between-views","title":"Navigating Between Views","text":"<p>To navigate to any registered view, simply use:</p> <p><pre><code>fv.view_go(\"name_of_view\")\n</code></pre> For example: <pre><code>fv.view_go(\"settings\")\n</code></pre></p>"},{"location":"getting-started/#notes_1","title":"Notes","text":"<ul> <li>You can set <code>history_debug=True</code> as an argument to either <code>view_go()</code> or <code>go_back()</code> to print the navigation flow and see exactly how the history is being handled in your app. <pre><code>fv.view_go(\"settings\", history_debug=True)\nfv.go_back(history_debug=True)\n</code></pre></li> </ul>"},{"location":"getting-started/#adding-controls-to-views","title":"Adding controls to views","text":"<p>FleetingViews supports two convenient methods for adding controls:</p> <ol> <li> <p><code>append()</code>     This method adds one or more controls to a specific view:</p> <p><pre><code>fv.append(\"view_name\", controls)\n</code></pre> <code>controls</code> can be:</p> <ul> <li>A single Flet control (e.g. <code>ft.Text(\"Hello\")</code>)</li> <li>A list of controls (e.g. <code>[ft.Text(\"Hello\"), ft.ElevatedButton(\"Click\")]</code>)</li> </ul> </li> <li> <p><code>wadd()</code>:</p> <p>A shorthand method to add controls to the currently active working view:</p> <p><pre><code>fv.wadd(controls)\n</code></pre> This is ideal for building views in sequence without repeating the view name every time.</p> <p>If you want to change the working view (for all future <code>wadd()</code> calls) use:</p> <pre><code>fv.set_working(\"view_name\")\n</code></pre> </li> </ol>"},{"location":"getting-started/#notes_2","title":"Notes","text":"<ul> <li>By default, the working view is the last declared view.</li> <li>Use <code>fv.set_working(\"view_name\")</code> to change the active working view for future wadd() calls.</li> <li>Both methods automatically trigger <code>page.update()</code>, so no need to call it manually (you can avoid this behaviour by setting <code>update=False</code> on the arguments!).</li> </ul>"},{"location":"getting-started/#going-back","title":"Going back","text":"<p>To return to the previous view:</p> <p><pre><code>fv.go_back()\n</code></pre> FleetingViews maintains a history of visited views. Once there's no more history, calling <code>go_back()</code> will return you to the root view.</p> <p>If you want to reset navigation history, use: <pre><code>fv.clean()\n</code></pre> This clears the navigation stack. The next <code>go_back()</code> will always lead to the root view.</p>"},{"location":"getting-started/#basic-fleetingviews-design","title":"Basic FleetingViews design","text":"<p>Here\u2019s a basic conceptual diagram of FleetingViews' routing system:</p> <p></p>"},{"location":"getting-started/#minimal-working-example","title":"Minimal working example","text":"<pre><code>import flet as ft\nimport FleetingViews as fleetingviews\n\ndef main(page: ft.Page):\n    views = {\n        \"home\": {\"bgcolor\": ft.colors.BLUE},\n        \"about\": {\"bgcolor\": ft.colors.GREEN},\n    }\n\n    fv = fleetingviews.create_views(view_definitions=views, page=page)\n    fv.set_working(\"home\")\n    fv.wadd(ft.Text(\"Welcome to the home page\"))\n    fv.set_working(\"about\")\n    fv.wadd(ft.Text(\"This is the about page\"))\n\n    fv.view_go(\"home\")\n\nft.app(target=main)\n</code></pre>"},{"location":"query_strings/","title":"Query Parameters","text":""},{"location":"query_strings/#query-parameters-v018","title":"Query Parameters (v0.1.8)","text":"<p>FleetingViews also allows you to pass and use query parameters in your views' URLs. These parameters can be used to store and retrieve dynamic information across different views.</p>"},{"location":"query_strings/#example-using-query-parameters","title":"Example: Using Query Parameters","text":"<p>Let's say you want to pass some parameters like <code>user_id</code> or <code>theme</code> when navigating between views. You can easily achieve this using query strings.</p>"},{"location":"query_strings/#define-your-views-with-query-parameters","title":"Define Your Views with Query Parameters","text":"<p>You can use the <code>params</code> argument to pass query parameters. Here's an example of how to use query parameters when navigating to a specific view:</p> <pre><code># Define views with query parameters in the URL\nview_definitions = {\n    \"home\": {\n        \"bgcolor\": ft.colors.BLUE_GREY,\n        \"vertical_alignment\": ft.MainAxisAlignment.CENTER,\n        \"horizontal_alignment\": ft.CrossAxisAlignment.CENTER,\n    },\n    \"settings\": {\n        \"bgcolor\": ft.colors.AMBER_900,\n        \"vertical_alignment\": ft.MainAxisAlignment.CENTER,\n        \"horizontal_alignment\": ft.CrossAxisAlignment.CENTER,\n    },\n    \"profile\": {\n        \"bgcolor\": ft.colors.LIGHT_GREEN,\n        \"vertical_alignment\": ft.MainAxisAlignment.CENTER,\n        \"horizontal_alignment\": ft.CrossAxisAlignment.CENTER,\n    },\n}\n\n# Create views\nfv = fleetingviews.create_views(view_definitions=view_definitions, page=page)\n\n# Navigate to 'profile' view with query parameters\nfv.view_go(\"profile?user_id=123&amp;theme=dark\")\n</code></pre>"},{"location":"query_strings/#retrieving-query-parameters","title":"Retrieving Query Parameters","text":"<p>Once you've navigated to a view with query parameters, you can access those parameters inside your view by using the getters on the FleetingViews instance.</p> <pre><code># Access query parameters inside the 'profile' view\ndef profile_view(fv):\n    user_id = fv.get_param(\"user_id\", \"guest\")\n    theme = fv.get_param(\"theme\", \"light\")\n\n# Use the parameters in your view\nprint(f\"User ID: {user_id}\")\nprint(f\"Theme: {theme}\")\n\n# Add some controls or logic based on the parameters\ncontrols = [\n    ft.Text(f\"Welcome, {user_id}!\"),\n    ft.Text(f\"Theme: {theme}\"),\n]\nfv.append(\"profile\", controls)\n</code></pre>"},{"location":"query_strings/#notes","title":"Notes","text":"<ul> <li>You can pass multiple query parameters in the URL by separating them with <code>&amp;</code>.</li> <li>The <code>get_param()</code> method is used to retrieve the parameters. If the parameter does not exist, you can provide a default value.</li> <li>Query parameters are a great way to make your views more dynamic and customizable based on user input or application state.</li> <li>FleetingViews <code>go_back()</code> method remembers not only the page and state, but also the parameters if they were given!</li> <li>Parameters are available as soon as <code>view_go()</code> is triggered, even before guards are evaluated!</li> </ul>"},{"location":"reactive/","title":"\ud83d\udd01 Reactive Observables &amp; Two-Way Binding (v0.2)","text":"<p>FleetingViews introduces a built-in reactivity system in v0.2, allowing you to declare shared observable values and create dynamic interfaces that respond automatically to user input or programmatic changes.</p>"},{"location":"reactive/#observable-values","title":"\ud83d\udce6 Observable Values","text":"<p>You can declare values that are shared and watched across different parts of your app.</p> <pre><code>dfv.define_observable(\"username\", \"Guest\")\n</code></pre> <p>Once defined, this value can be subscribed to by any number of controls or logic handlers.</p>"},{"location":"reactive/#subscribing-to-changes","title":"\ud83d\udc40 Subscribing to Changes","text":"<p>You can subscribe any control (that has a <code>.value</code>) or function to an observable key. When the value changes, all subscribers are updated.</p> <pre><code>username_label = ft.Text()\ndfv.subscribe(\"username\", username_label)\n\n# This updates the label automatically:\ndfv.set_observable(\"username\", \"Bruno\")\n</code></pre> <p>You can also provide a handler function:</p> <pre><code>def on_username_change(value):\n    print(\"New username:\", value)\n\ndfv.subscribe(\"username\", handler=on_username_change)\n</code></pre> <p>Or both:</p> <pre><code>dfv.subscribe(\"username\", username_label, handler=on_username_change)\n</code></pre>"},{"location":"reactive/#two-way-data-binding","title":"\ud83d\udd01 Two-Way Data Binding","text":"<p>The <code>bind_to_control()</code> method creates a reactive link in both directions between a control (e.g. <code>TextField</code>) and an observable key.</p> <pre><code>input_name = ft.TextField()\ndfv.bind_to_control(\"username\", input_name)\n</code></pre> <p>Now:</p> <ul> <li>Changing the field updates the observable.</li> <li>Updating the observable updates the field.</li> </ul> <p>You can bind multiple controls to the same key:</p> <pre><code>fv.bind_to_control(\"email\", email_input)\nfv.subscribe(\"email\", email_preview)\n</code></pre>"},{"location":"reactive/#unsubscribing-and-unbinding","title":"\ud83d\udd04 Unsubscribing and Unbinding","text":""},{"location":"reactive/#unsubscribe-a-control-or-function","title":"Unsubscribe a control or function:","text":"<pre><code>dfv.unsubscribe(\"username\", username_label)\ndfv.unsubscribe(\"username\", on_username_change)\n</code></pre>"},{"location":"reactive/#unbind-a-two-way-binding","title":"Unbind a two-way binding:","text":"<pre><code>dfv.unbind_control(\"username\", input_name)\n</code></pre> <p>This removes both the subscription and the <code>on_change</code> listener from the control.</p>"},{"location":"reactive/#full-lifecycle-example","title":"\ud83d\udcda Full Lifecycle Example","text":"<pre><code>fv.define_observable(\"username\", \"\")\n\ninput_field = ft.TextField()\noutput_text = ft.Text()\n\nfv.bind_to_control(\"username\", input_field)\nfv.subscribe(\"username\", output_text)\n\n# Result:\n# Typing in the input updates the observable and the text\n# Updating the observable updates both\nfv.set_observable(\"username\", \"Bruno\")\n</code></pre>"},{"location":"reactive/#why-use-reactive-observables","title":"\ud83e\udde0 Why Use Reactive Observables?","text":"<ul> <li>Clean separation of logic and presentation</li> <li>Auto-update UI from data, and vice versa</li> <li>No need to manually call <code>.update()</code> on multiple elements</li> <li>Centralized state with full reactivity</li> </ul> <p>This makes it easier to build forms, settings pages, dashboards, and any interface where state and UI must stay in sync.</p>"},{"location":"reactive/#coming-soon-v021","title":"\ud83e\udde9 Coming Soon (v0.2.1+)","text":"<ul> <li><code>define_computed()</code> for derived values</li> <li><code>watch()</code> and <code>watch_many()</code> to react to multiple observables</li> <li>Persistence with <code>enable_persistence()</code></li> </ul> <p>Reactive state in FleetingViews brings frontend-like power to Python + Flet, without complexity.</p>"}]}