{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Welcome to FleetingViews \ud83d\udc4b FleetingViews is a lightweight but powerful utility class that simplifies view management in Flet applications. Inspired by modern frontend routing systems, FleetingViews provides tools to create, switch, animate, and control views with ease\u2014no boilerplate, no fuss. \u2728 Features (v0.1.8) \ud83d\ude80 Easy view declaration and dynamic navigation \ud83e\udded Built-in navigation history with go_back() \ud83e\uddf1 Add controls dynamically from views \ud83c\udfad Animated transitions between views \ud83e\udde9 Lifecycle hooks ( on_mount , on_dismount , on_view_change ) \ud83d\udee1\ufe0f Guard functions to protect certain views \ud83e\uddc3 Support for drawers, FABs, AppBars. \ud83e\udde9 Easy to modularize view definitions and logic \ud83c\udf10 Easily pass and handle query parameters in views with FleetingViews \ud83d\udd04 Seamlessly share data across views and components with FleetingViews \ud83d\udce6 Installation pip install fleetingviews \u2753 Why FleetingViews? Managing multiple views in a Flet app can quickly get messy. FleetingViews helps you: \ud83e\uddf9 Organize your views declaratively \ud83d\udd04 Handle transitions and user navigation easily \ud83e\udde0 Inject custom behavior with guards and hooks \ud83e\uddd1\u200d\ud83d\udcbb Focus on your app logic, not view plumbing \u201cWith FleetingViews, you think about what your app does not how to juggle UI blocks.\u201d Repository","title":"Home"},{"location":"#welcome-to-fleetingviews","text":"FleetingViews is a lightweight but powerful utility class that simplifies view management in Flet applications. Inspired by modern frontend routing systems, FleetingViews provides tools to create, switch, animate, and control views with ease\u2014no boilerplate, no fuss.","title":"Welcome to FleetingViews \ud83d\udc4b"},{"location":"#features-v018","text":"\ud83d\ude80 Easy view declaration and dynamic navigation \ud83e\udded Built-in navigation history with go_back() \ud83e\uddf1 Add controls dynamically from views \ud83c\udfad Animated transitions between views \ud83e\udde9 Lifecycle hooks ( on_mount , on_dismount , on_view_change ) \ud83d\udee1\ufe0f Guard functions to protect certain views \ud83e\uddc3 Support for drawers, FABs, AppBars. \ud83e\udde9 Easy to modularize view definitions and logic \ud83c\udf10 Easily pass and handle query parameters in views with FleetingViews \ud83d\udd04 Seamlessly share data across views and components with FleetingViews","title":"\u2728 Features (v0.1.8)"},{"location":"#installation","text":"pip install fleetingviews","title":"\ud83d\udce6 Installation"},{"location":"#why-fleetingviews","text":"Managing multiple views in a Flet app can quickly get messy. FleetingViews helps you: \ud83e\uddf9 Organize your views declaratively \ud83d\udd04 Handle transitions and user navigation easily \ud83e\udde0 Inject custom behavior with guards and hooks \ud83e\uddd1\u200d\ud83d\udcbb Focus on your app logic, not view plumbing \u201cWith FleetingViews, you think about what your app does not how to juggle UI blocks.\u201d","title":"\u2753 Why FleetingViews?"},{"location":"#repository","text":"","title":"Repository"},{"location":"404_page/","text":"Welcome to FleetingViews \ud83d\udc4b FleetingViews is a lightweight but powerful utility class that simplifies view management in Flet applications. Inspired by modern frontend routing systems, FleetingViews provides tools to create, switch, animate, and control views with ease\u2014no boilerplate, no fuss. \u2728 Features (v0.1.8) \ud83d\ude80 Easy view declaration and dynamic navigation \ud83e\udded Built-in navigation history with go_back() \ud83e\uddf1 Add controls dynamically from views \ud83c\udfad Animated transitions between views \ud83e\udde9 Lifecycle hooks ( on_mount , on_dismount , on_view_change ) \ud83d\udee1\ufe0f Guard functions to protect certain views \ud83e\uddc3 Support for drawers, FABs, AppBars. \ud83e\udde9 Easy to modularize view definitions and logic \ud83c\udf10 Easily pass and handle query parameters in views with FleetingViews \ud83d\udd04 Seamlessly share data across views and components with FleetingViews \ud83d\udce6 Installation pip install fleetingviews \u2753 Why FleetingViews? Managing multiple views in a Flet app can quickly get messy. FleetingViews helps you: \ud83e\uddf9 Organize your views declaratively \ud83d\udd04 Handle transitions and user navigation easily \ud83e\udde0 Inject custom behavior with guards and hooks \ud83e\uddd1\u200d\ud83d\udcbb Focus on your app logic, not view plumbing \u201cWith FleetingViews, you think about what your app does not how to juggle UI blocks.\u201d Repository","title":"404_handler"},{"location":"404_page/#welcome-to-fleetingviews","text":"FleetingViews is a lightweight but powerful utility class that simplifies view management in Flet applications. Inspired by modern frontend routing systems, FleetingViews provides tools to create, switch, animate, and control views with ease\u2014no boilerplate, no fuss.","title":"Welcome to FleetingViews \ud83d\udc4b"},{"location":"404_page/#features-v018","text":"\ud83d\ude80 Easy view declaration and dynamic navigation \ud83e\udded Built-in navigation history with go_back() \ud83e\uddf1 Add controls dynamically from views \ud83c\udfad Animated transitions between views \ud83e\udde9 Lifecycle hooks ( on_mount , on_dismount , on_view_change ) \ud83d\udee1\ufe0f Guard functions to protect certain views \ud83e\uddc3 Support for drawers, FABs, AppBars. \ud83e\udde9 Easy to modularize view definitions and logic \ud83c\udf10 Easily pass and handle query parameters in views with FleetingViews \ud83d\udd04 Seamlessly share data across views and components with FleetingViews","title":"\u2728 Features (v0.1.8)"},{"location":"404_page/#installation","text":"pip install fleetingviews","title":"\ud83d\udce6 Installation"},{"location":"404_page/#why-fleetingviews","text":"Managing multiple views in a Flet app can quickly get messy. FleetingViews helps you: \ud83e\uddf9 Organize your views declaratively \ud83d\udd04 Handle transitions and user navigation easily \ud83e\udde0 Inject custom behavior with guards and hooks \ud83e\uddd1\u200d\ud83d\udcbb Focus on your app logic, not view plumbing \u201cWith FleetingViews, you think about what your app does not how to juggle UI blocks.\u201d","title":"\u2753 Why FleetingViews?"},{"location":"404_page/#repository","text":"","title":"Repository"},{"location":"Hooks_and_guards/","text":"\ud83d\udd12 Hooks & Guards in FleetingViews (v0.1.8) FleetingViews supports lifecycle hooks and navigation guards to help you manage your views' logic more dynamically and safely. \ud83e\ude9d Lifecycle Hooks You can attach functions to specific views that run when the view is mounted or dismounted . These functions are useful for initializing resources, fetching data, or cleaning up when navigating between views. Supported Hooks: on_mount : Runs when the view is shown . on_dismount : Runs just before the view is hidden . Each of these can accept a single function or a list of functions , and will be executed in the order provided. Example def fetch_user_data ( ctx ): print ( \"Fetching user data...\" ) def save_changes ( ctx ): print ( \"Saving form changes...\" ) fv . add_hooks_or_guards ( \"profile\" , { \"on_mount\" : fetch_user_data , \"on_dismount\" : save_changes , }) You can also pass multiple functions: fv . add_hooks_or_guards ( \"profile\" , { \"on_mount\" : [ func_a , func_b ], \"on_dismount\" : [ cleanup1 , cleanup2 ], }) You can also define hooks directly inside your view_definitions : def my_on_mount_hook ( ctx ): print ( f \"Hello page { ctx . actual_view . route } { ctx . _query_params } \" ) # View definitions with specific configurations view_definitions = { \"home\" : { \"bgcolor\" : ft . colors . BLUE_GREY , \"vertical_alignment\" : ft . MainAxisAlignment . CENTER , \"horizontal_alignment\" : ft . CrossAxisAlignment . CENTER , \"on_mount\" : my_on_mount_hook }, \"settings\" : { \"bgcolor\" : ft . colors . AMBER_900 , \"vertical_alignment\" : ft . MainAxisAlignment . CENTER , \"horizontal_alignment\" : ft . CrossAxisAlignment . CENTER , } } Notes: It is advised that the hooks are given a context argument to get useful information in the manager ex: ctx._query_params will give you the parameter, you can also use ctx.get_params() . You can't create hooks that receive more than ctx . on_view_change Hook: You can now define an on_view_change callback that gets executed every time the active view changes , regardless of where the navigation came from. This is useful for analytics, layout adjustments, logging, or global effects when the view changes. \u26a0\ufe0f For maintainability reasons, only one on_view_change handler is allowed. It should be a single callable function. All guards must accept exactly two arguments: view_name and params Example: def my_global_view_change_handler ( view_name : str , params ): print ( f \"Changed to view: { view_name } with params: { params } \" ) fv . on_view_change = my_global_view_change_handler \ud83d\udee1\ufe0f Navigation Guards Guards are functions that run before changing to a specific view . They determine whether or not the view transition should happen. Each guard function must return True or False : Return True to allow navigation. Return False to prevent the view from being shown. This is useful for authentication checks, permission validation, or confirming unsaved changes. Important \u26a0\ufe0f If any of the guards return a False , the navigation is stopped and no hooks or events will be triggered. All guards must accept exactly two arguments: ctx and name .. ctx will be the FleetingViews manager and name the name of the view thats being evaluated. Example def is_user_logged_in ( ctx , name ): # Only allow access if the user is logged in return session . get ( \"logged_in\" , False ) fv . add_hooks_or_guards ( \"dashboard\" , { \"guards\" : is_user_logged_in }) As with hooks, you can add a list of them or define them in the view_definitions : def is_user_logged_in ( ctx , name ): # Only allow access if the user is logged in return session . get ( \"logged_in\" , False ) # View definitions with specific configurations view_definitions = { \"home\" : { \"bgcolor\" : ft . colors . BLUE_GREY , \"vertical_alignment\" : ft . MainAxisAlignment . CENTER , \"horizontal_alignment\" : ft . CrossAxisAlignment . CENTER , \"guards\" : is_user_logged_in }, \"settings\" : { \"bgcolor\" : ft . colors . AMBER_900 , \"vertical_alignment\" : ft . MainAxisAlignment . CENTER , \"horizontal_alignment\" : ft . CrossAxisAlignment . CENTER , } } Full Lifecycle Navigation attempt -> Run Guards -> [All True?] -> Run on_dismounts -> Change View -> Run on_mounts -> Run on_view_change","title":"Hooks and Guards"},{"location":"Hooks_and_guards/#hooks-guards-in-fleetingviews-v018","text":"FleetingViews supports lifecycle hooks and navigation guards to help you manage your views' logic more dynamically and safely.","title":"\ud83d\udd12 Hooks &amp; Guards in FleetingViews (v0.1.8)"},{"location":"Hooks_and_guards/#lifecycle-hooks","text":"You can attach functions to specific views that run when the view is mounted or dismounted . These functions are useful for initializing resources, fetching data, or cleaning up when navigating between views.","title":"\ud83e\ude9d Lifecycle Hooks"},{"location":"Hooks_and_guards/#supported-hooks","text":"on_mount : Runs when the view is shown . on_dismount : Runs just before the view is hidden . Each of these can accept a single function or a list of functions , and will be executed in the order provided.","title":"Supported Hooks:"},{"location":"Hooks_and_guards/#example","text":"def fetch_user_data ( ctx ): print ( \"Fetching user data...\" ) def save_changes ( ctx ): print ( \"Saving form changes...\" ) fv . add_hooks_or_guards ( \"profile\" , { \"on_mount\" : fetch_user_data , \"on_dismount\" : save_changes , }) You can also pass multiple functions: fv . add_hooks_or_guards ( \"profile\" , { \"on_mount\" : [ func_a , func_b ], \"on_dismount\" : [ cleanup1 , cleanup2 ], }) You can also define hooks directly inside your view_definitions : def my_on_mount_hook ( ctx ): print ( f \"Hello page { ctx . actual_view . route } { ctx . _query_params } \" ) # View definitions with specific configurations view_definitions = { \"home\" : { \"bgcolor\" : ft . colors . BLUE_GREY , \"vertical_alignment\" : ft . MainAxisAlignment . CENTER , \"horizontal_alignment\" : ft . CrossAxisAlignment . CENTER , \"on_mount\" : my_on_mount_hook }, \"settings\" : { \"bgcolor\" : ft . colors . AMBER_900 , \"vertical_alignment\" : ft . MainAxisAlignment . CENTER , \"horizontal_alignment\" : ft . CrossAxisAlignment . CENTER , } }","title":"Example"},{"location":"Hooks_and_guards/#notes","text":"It is advised that the hooks are given a context argument to get useful information in the manager ex: ctx._query_params will give you the parameter, you can also use ctx.get_params() . You can't create hooks that receive more than ctx .","title":"Notes:"},{"location":"Hooks_and_guards/#on_view_change-hook","text":"You can now define an on_view_change callback that gets executed every time the active view changes , regardless of where the navigation came from. This is useful for analytics, layout adjustments, logging, or global effects when the view changes. \u26a0\ufe0f For maintainability reasons, only one on_view_change handler is allowed. It should be a single callable function. All guards must accept exactly two arguments: view_name and params Example: def my_global_view_change_handler ( view_name : str , params ): print ( f \"Changed to view: { view_name } with params: { params } \" ) fv . on_view_change = my_global_view_change_handler","title":"on_view_change Hook:"},{"location":"Hooks_and_guards/#navigation-guards","text":"Guards are functions that run before changing to a specific view . They determine whether or not the view transition should happen. Each guard function must return True or False : Return True to allow navigation. Return False to prevent the view from being shown. This is useful for authentication checks, permission validation, or confirming unsaved changes.","title":"\ud83d\udee1\ufe0f Navigation Guards"},{"location":"Hooks_and_guards/#important","text":"\u26a0\ufe0f If any of the guards return a False , the navigation is stopped and no hooks or events will be triggered. All guards must accept exactly two arguments: ctx and name .. ctx will be the FleetingViews manager and name the name of the view thats being evaluated.","title":"Important"},{"location":"Hooks_and_guards/#example_1","text":"def is_user_logged_in ( ctx , name ): # Only allow access if the user is logged in return session . get ( \"logged_in\" , False ) fv . add_hooks_or_guards ( \"dashboard\" , { \"guards\" : is_user_logged_in }) As with hooks, you can add a list of them or define them in the view_definitions : def is_user_logged_in ( ctx , name ): # Only allow access if the user is logged in return session . get ( \"logged_in\" , False ) # View definitions with specific configurations view_definitions = { \"home\" : { \"bgcolor\" : ft . colors . BLUE_GREY , \"vertical_alignment\" : ft . MainAxisAlignment . CENTER , \"horizontal_alignment\" : ft . CrossAxisAlignment . CENTER , \"guards\" : is_user_logged_in }, \"settings\" : { \"bgcolor\" : ft . colors . AMBER_900 , \"vertical_alignment\" : ft . MainAxisAlignment . CENTER , \"horizontal_alignment\" : ft . CrossAxisAlignment . CENTER , } }","title":"Example"},{"location":"Hooks_and_guards/#full-lifecycle","text":"Navigation attempt -> Run Guards -> [All True?] -> Run on_dismounts -> Change View -> Run on_mounts -> Run on_view_change","title":"Full Lifecycle"},{"location":"animations/","text":"Animations Availible from V0.1.2 This version of FleetingViews now enables view transitions with customizable position and duration for every view_go() and go_back() call. For example, let's initialize some views in our project: # View definitions with specific configurations view_definitions = { 'home' : { 'bgcolor' : ft . colors . RED , 'vertical_alignment' : ft . MainAxisAlignment . CENTER , 'horizontal_alignment' : ft . CrossAxisAlignment . CENTER }, 'projects' : { 'bgcolor' : ft . colors . PURPLE , } } fv = fleetingviews . create_views ( view_definitions = view_definitions , page = page ) Now, all that is left is to call one of the methods as follows: # Navigate to the \"projects\" view with a 300ms animation from the right fv . view_go ( \"projects\" , duration = 300 , mode = \"right\" ) By adding the duration parameter with a value above 0, FleetingViews will know that the call is intended to have an animation that lasts duration milliseconds. You can also declare the animation mode that you prefer from the options below: 1. top_left (default) 2. top 3. top_right 4. right 5. bottom_right 6. bottom 7. bottom_left 8. left #For example fv . view_go ( \"projects\" , duration = 300 , mode = \"right\" )","title":"Animations"},{"location":"animations/#animations","text":"","title":"Animations"},{"location":"animations/#availible-from-v012","text":"This version of FleetingViews now enables view transitions with customizable position and duration for every view_go() and go_back() call. For example, let's initialize some views in our project: # View definitions with specific configurations view_definitions = { 'home' : { 'bgcolor' : ft . colors . RED , 'vertical_alignment' : ft . MainAxisAlignment . CENTER , 'horizontal_alignment' : ft . CrossAxisAlignment . CENTER }, 'projects' : { 'bgcolor' : ft . colors . PURPLE , } } fv = fleetingviews . create_views ( view_definitions = view_definitions , page = page ) Now, all that is left is to call one of the methods as follows: # Navigate to the \"projects\" view with a 300ms animation from the right fv . view_go ( \"projects\" , duration = 300 , mode = \"right\" ) By adding the duration parameter with a value above 0, FleetingViews will know that the call is intended to have an animation that lasts duration milliseconds. You can also declare the animation mode that you prefer from the options below:","title":"Availible from V0.1.2"},{"location":"animations/#1-top_left-default","text":"","title":"1. top_left (default)"},{"location":"animations/#2-top","text":"","title":"2. top"},{"location":"animations/#3-top_right","text":"","title":"3. top_right"},{"location":"animations/#4-right","text":"","title":"4. right"},{"location":"animations/#5-bottom_right","text":"","title":"5. bottom_right"},{"location":"animations/#6-bottom","text":"","title":"6. bottom"},{"location":"animations/#7-bottom_left","text":"","title":"7. bottom_left"},{"location":"animations/#8-left","text":"#For example fv . view_go ( \"projects\" , duration = 300 , mode = \"right\" )","title":"8. left"},{"location":"features/","text":"Features V(0.1.0) 1. Automatic View Creation with Customized Design: Quickly create views with specified settings, including background colors, alignments, and other attributes. 2. View History for \"Back\" Calls: Navigate back to previous views effortlessly, enhancing the user experience. 3. Custom Append Methods: Easily add controls to specific views with custom appends methods. 4. Clear Method: Reset the view history with a simple clear method. V(0.1.2) View Change Custom Animations! Easily add transitions for any view_go() call with custom duration and modes. Customizable page.update() Calls for Page Building in the Background Now you are able to add controls in the \"background\" without updating the page by setting update=False on wadd() and append() methods. V(0.1.8) 1. Query Parameters for Dynamic Views! Easily pass and retrieve query parameters in your views using get_param(\"param_name\", \"Default if not existent\") or get_params() . Customize views based on URL parameters for a more dynamic user experience. \ud83e\udde9 Example: # Retrieve a query parameter param = fv . get_param ( \"param_name\" , default_value ) #Retrieve all parameters params = fv . get_params () 2. Shared Data Between Views! Share data across multiple views with a single FleetingViews instance. The shared data object can hold any values or objects that need to persist between views. Example: # Set shared data fv . set_shared ( \"user_info\" , { \"name\" : \"John\" , \"age\" : 30 }) # Retrieve shared data in a different view user_info = fv . get_shared ( \"user_info\" , default_value ) 3. Enhanced View Navigation with URL Parameters! The view_go() method now supports URL parameters, making it easier to navigate to views with specific configurations or user data embedded in the URL. Example: fv . view_go ( \"settings?theme=dark&lang=en\" ) 4. Improved go_back() Handling with Parameters! The go_back() method now remembers not only the view but also any query parameters, making it easier to return to a specific state in your application. 5. Added Lifecycle Hooks! FleetingViews now supports lifecycle hooks, allowing you to add custom behavior when views are mounted or unmounted. Use on_mount and on_dismount hooks to manage side effects such as fetching data, setting states, or cleaning up resources when switching between views. Example: You can do it in the very definitions of your views: def my_on_mount_hook ( ctx ): print ( f \"Hello page { ctx . actual_view . route } { ctx . _query_params } \" ) # View definitions with specific configurations view_definitions = { \"home\" : { \"bgcolor\" : ft . colors . BLUE_GREY , \"vertical_alignment\" : ft . MainAxisAlignment . CENTER , \"horizontal_alignment\" : ft . CrossAxisAlignment . CENTER , \"on_mount\" : my_on_mount_hook }, \"settings\" : { \"bgcolor\" : ft . colors . AMBER_900 , \"vertical_alignment\" : ft . MainAxisAlignment . CENTER , \"horizontal_alignment\" : ft . CrossAxisAlignment . CENTER , } } Or you can add more callables during execution!. def my_on_mount_hook ( ctx ): print ( f \"Hello page { ctx . actual_view . route } { ctx . _query_params } \" ) # View definitions with specific configurations view_definitions = { \"home\" : { \"bgcolor\" : ft . colors . BLUE_GREY , \"vertical_alignment\" : ft . MainAxisAlignment . CENTER , \"horizontal_alignment\" : ft . CrossAxisAlignment . CENTER , }, \"settings\" : { \"bgcolor\" : ft . colors . AMBER_900 , \"vertical_alignment\" : ft . MainAxisAlignment . CENTER , \"horizontal_alignment\" : ft . CrossAxisAlignment . CENTER , } } fv = fleetingViews . create_views ( view_definitions = view_definitions , page = page ) fv . add_hooks_or_guards ( \"home\" , { \"on_mount\" : my_on_mount_hook }) Notes You can use fv.add_hooks_or_guards() to attach one or multiple callables to a view\u2019s on_mount , on_dismount , or guards lifecycle events. Check the full documentation for usage examples and more details! 6. Missing Page Handling! When navigating to a view that doesn\u2019t exist, FleetingViews now handles missing pages gracefully by redirecting users to a fallback page you configure. fv . view_go ( \"non_existent_page\" ) By default, this will automatically redirect to the special \"404_not_found\" view, which comes with a default error message (similar to common hosting platforms) and a button that sends the user back to the root view. This handler is always created unless explicitly disabled: fv = fleetingViews . create_views ( view_definitions = view_definitions , page = page , fallback_404 = False ) Of course, you can fully customize the \"404_not_found\" page just like any other view: view_definitions = { 'home' : { 'bgcolor' : ft . Colors . BLUE_GREY , 'vertical_alignment' : ft . MainAxisAlignment . CENTER , 'horizontal_alignment' : ft . CrossAxisAlignment . CENTER , \"appbar\" : appbar , \"on_mount\" : my_on_mount_hook }, ###EDITION OF NOT FOUND VIEW '404_not_found' : { 'bgcolor' : ft . Colors . RED_300 , 'vertical_alignment' : ft . MainAxisAlignment . CENTER , 'horizontal_alignment' : ft . CrossAxisAlignment . CENTER , \"controls\" : [ ft . Text ( \"Oops! This page doesn't exist (404)\" , size = 30 , weight = \"bold\" , color = ft . Colors . BLACK ), ft . Text ( \"Please check the URL or go back to a known view.\" , color = ft . Colors . BLACK )], \"appbar\" : appbar , }, } 7. Added on_view_change handler You can now define an on_view_change callback that gets executed every time the active view changes , regardless of where the navigation came from. This is useful for analytics, layout adjustments, logging, or global effects when the view changes. \u26a0\ufe0f For maintainability reasons, only one on_view_change handler is allowed. It should be a single callable function. Example: def my_global_view_change_handler ( view_name : str , params ): print ( f \"Changed to view: { view_name } with params: { params } \" ) fv . on_view_change = my_global_view_change_handler","title":"Features"},{"location":"features/#features","text":"","title":"Features"},{"location":"features/#v010","text":"","title":"V(0.1.0)"},{"location":"features/#1-automatic-view-creation-with-customized-design","text":"Quickly create views with specified settings, including background colors, alignments, and other attributes.","title":"1. Automatic View Creation with Customized Design:"},{"location":"features/#2-view-history-for-back-calls","text":"Navigate back to previous views effortlessly, enhancing the user experience.","title":"2. View History for \"Back\" Calls:"},{"location":"features/#3-custom-append-methods","text":"Easily add controls to specific views with custom appends methods.","title":"3. Custom Append Methods:"},{"location":"features/#4-clear-method","text":"Reset the view history with a simple clear method.","title":"4. Clear Method:"},{"location":"features/#v012","text":"","title":"V(0.1.2)"},{"location":"features/#view-change-custom-animations","text":"Easily add transitions for any view_go() call with custom duration and modes.","title":"View Change Custom Animations!"},{"location":"features/#customizable-pageupdate-calls-for-page-building-in-the-background","text":"Now you are able to add controls in the \"background\" without updating the page by setting update=False on wadd() and append() methods.","title":"Customizable page.update() Calls for Page Building in the Background"},{"location":"features/#v018","text":"","title":"V(0.1.8)"},{"location":"features/#1-query-parameters-for-dynamic-views","text":"Easily pass and retrieve query parameters in your views using get_param(\"param_name\", \"Default if not existent\") or get_params() . Customize views based on URL parameters for a more dynamic user experience. \ud83e\udde9 Example: # Retrieve a query parameter param = fv . get_param ( \"param_name\" , default_value ) #Retrieve all parameters params = fv . get_params ()","title":"1. Query Parameters for Dynamic Views!"},{"location":"features/#2-shared-data-between-views","text":"Share data across multiple views with a single FleetingViews instance. The shared data object can hold any values or objects that need to persist between views. Example: # Set shared data fv . set_shared ( \"user_info\" , { \"name\" : \"John\" , \"age\" : 30 }) # Retrieve shared data in a different view user_info = fv . get_shared ( \"user_info\" , default_value )","title":"2. Shared Data Between Views!"},{"location":"features/#3-enhanced-view-navigation-with-url-parameters","text":"The view_go() method now supports URL parameters, making it easier to navigate to views with specific configurations or user data embedded in the URL. Example: fv . view_go ( \"settings?theme=dark&lang=en\" )","title":"3. Enhanced View Navigation with URL Parameters!"},{"location":"features/#4-improved-go_back-handling-with-parameters","text":"The go_back() method now remembers not only the view but also any query parameters, making it easier to return to a specific state in your application.","title":"4. Improved go_back() Handling with Parameters!"},{"location":"features/#5-added-lifecycle-hooks","text":"FleetingViews now supports lifecycle hooks, allowing you to add custom behavior when views are mounted or unmounted. Use on_mount and on_dismount hooks to manage side effects such as fetching data, setting states, or cleaning up resources when switching between views. Example: You can do it in the very definitions of your views: def my_on_mount_hook ( ctx ): print ( f \"Hello page { ctx . actual_view . route } { ctx . _query_params } \" ) # View definitions with specific configurations view_definitions = { \"home\" : { \"bgcolor\" : ft . colors . BLUE_GREY , \"vertical_alignment\" : ft . MainAxisAlignment . CENTER , \"horizontal_alignment\" : ft . CrossAxisAlignment . CENTER , \"on_mount\" : my_on_mount_hook }, \"settings\" : { \"bgcolor\" : ft . colors . AMBER_900 , \"vertical_alignment\" : ft . MainAxisAlignment . CENTER , \"horizontal_alignment\" : ft . CrossAxisAlignment . CENTER , } } Or you can add more callables during execution!. def my_on_mount_hook ( ctx ): print ( f \"Hello page { ctx . actual_view . route } { ctx . _query_params } \" ) # View definitions with specific configurations view_definitions = { \"home\" : { \"bgcolor\" : ft . colors . BLUE_GREY , \"vertical_alignment\" : ft . MainAxisAlignment . CENTER , \"horizontal_alignment\" : ft . CrossAxisAlignment . CENTER , }, \"settings\" : { \"bgcolor\" : ft . colors . AMBER_900 , \"vertical_alignment\" : ft . MainAxisAlignment . CENTER , \"horizontal_alignment\" : ft . CrossAxisAlignment . CENTER , } } fv = fleetingViews . create_views ( view_definitions = view_definitions , page = page ) fv . add_hooks_or_guards ( \"home\" , { \"on_mount\" : my_on_mount_hook })","title":"5. Added Lifecycle Hooks!"},{"location":"features/#notes","text":"You can use fv.add_hooks_or_guards() to attach one or multiple callables to a view\u2019s on_mount , on_dismount , or guards lifecycle events. Check the full documentation for usage examples and more details!","title":"Notes"},{"location":"features/#6-missing-page-handling","text":"When navigating to a view that doesn\u2019t exist, FleetingViews now handles missing pages gracefully by redirecting users to a fallback page you configure. fv . view_go ( \"non_existent_page\" ) By default, this will automatically redirect to the special \"404_not_found\" view, which comes with a default error message (similar to common hosting platforms) and a button that sends the user back to the root view. This handler is always created unless explicitly disabled: fv = fleetingViews . create_views ( view_definitions = view_definitions , page = page , fallback_404 = False ) Of course, you can fully customize the \"404_not_found\" page just like any other view: view_definitions = { 'home' : { 'bgcolor' : ft . Colors . BLUE_GREY , 'vertical_alignment' : ft . MainAxisAlignment . CENTER , 'horizontal_alignment' : ft . CrossAxisAlignment . CENTER , \"appbar\" : appbar , \"on_mount\" : my_on_mount_hook }, ###EDITION OF NOT FOUND VIEW '404_not_found' : { 'bgcolor' : ft . Colors . RED_300 , 'vertical_alignment' : ft . MainAxisAlignment . CENTER , 'horizontal_alignment' : ft . CrossAxisAlignment . CENTER , \"controls\" : [ ft . Text ( \"Oops! This page doesn't exist (404)\" , size = 30 , weight = \"bold\" , color = ft . Colors . BLACK ), ft . Text ( \"Please check the URL or go back to a known view.\" , color = ft . Colors . BLACK )], \"appbar\" : appbar , }, }","title":"6. Missing Page Handling!"},{"location":"features/#7-added-on_view_change-handler","text":"You can now define an on_view_change callback that gets executed every time the active view changes , regardless of where the navigation came from. This is useful for analytics, layout adjustments, logging, or global effects when the view changes. \u26a0\ufe0f For maintainability reasons, only one on_view_change handler is allowed. It should be a single callable function. Example: def my_global_view_change_handler ( view_name : str , params ): print ( f \"Changed to view: { view_name } with params: { params } \" ) fv . on_view_change = my_global_view_change_handler","title":"7. Added on_view_change handler"},{"location":"getting-started/","text":"Getting Started Installation To install FleetingViews, run pip install fleetingviews To upgrade to the latest version: pip install fleetingviews --upgrade Import import FleetingViews as fleetingviews Defining Your Views Start by defining your views using a simple dictionary structure. Each key is a view name, and its value is a dictionary of view-specific configurations. # View definitions with specific configurations view_definitions = { \"home\" : { \"bgcolor\" : ft . colors . BLUE_GREY , \"vertical_alignment\" : ft . MainAxisAlignment . CENTER , \"horizontal_alignment\" : ft . CrossAxisAlignment . CENTER , }, \"settings\" : { \"bgcolor\" : ft . colors . AMBER_900 , \"vertical_alignment\" : ft . MainAxisAlignment . CENTER , \"horizontal_alignment\" : ft . CrossAxisAlignment . CENTER , }, \"projects\" : { \"bgcolor\" : ft . colors . BLACK , \"vertical_alignment\" : ft . MainAxisAlignment . CENTER , \"horizontal_alignment\" : ft . CrossAxisAlignment . CENTER , }, } Notes This is the most basic example. We'll cover more advanced definitions later on. Any omitted argument will fall back to Flet\u2019s default values. You can declare views in any order, but the first one will be treated as the root view (i.e., the default entry point of your app). Initializing FleetingViews Once you\u2019ve defined your views, create a FleetingViews object: fv = fleetingviews . create_views ( view_definitions = view_definitions , page = page ) That\u2019s it! One line of code and your views are ready. Navigating Between Views To navigate to any registered view, simply use: fv . view_go ( \"name_of_view\" ) For example: fv . view_go ( \"settings\" ) Notes: You can set history_debug=True as an argument to either view_go() or go_back() to print the navigation flow and see exactly how the history is being handled in your app. fv . view_go ( \"settings\" , history_debug = True ) fv . go_back ( history_debug = True ) Adding controls to views FleetingViews supports two convenient methods for adding controls: append() This method adds one or more controls to a specific view: fv . append ( \"view_name\" , controls ) controls can be: * A single Flet control (e.g. ft.Text(\"Hello\") ) * A list of controls (e.g. [ft.Text(\"Hello\"), ft.ElevatedButton(\"Click\")] ) wadd() : A shorthand method to add controls to the currently active working view: fv . wadd ( controls ) This is ideal for building views in sequence without repeating the view name every time. If you want to change the working view (for all future wadd() calls) use: fv . set_working ( \"view_name\" ) Notes By default, the working view is the last declared view . Use fv.set_working(\"view_name\") to change the active working view for future wadd() calls. Both methods automatically trigger page.update() , so no need to call it manually (you can avoid this behaviour by setting update=False on the arguments!). Going back To return to the previous view: fv . go_back () FleetingViews maintains a history of visited views. Once there's no more history, calling go_back() will return you to the root view. If you want to reset navigation history , use: fv . clean () This clears the navigation stack. The next go_back() will always lead to the root view. Basic FleetingViews design Here\u2019s a basic conceptual diagram of FleetingViews' routing system: [Root View] \u2193 [View A] \u2190 go_back() \u2193 [View B] \u2190 go_back() \u2193 [View C] \u2190 go_back() Or visually: Minimal working example import flet as ft import FleetingViews as fleetingviews def main ( page : ft . Page ): views = { \"home\" : { \"bgcolor\" : ft . colors . BLUE }, \"about\" : { \"bgcolor\" : ft . colors . GREEN }, } fv = fleetingviews . create_views ( view_definitions = views , page = page ) fv . wadd ( ft . Text ( \"Welcome to the home page\" )) fv . set_working ( \"about\" ) fv . wadd ( ft . Text ( \"This is the about page\" )) fv . view_go ( \"home\" ) ft . app ( target = main )","title":"Getting Started"},{"location":"getting-started/#getting-started","text":"","title":"Getting Started"},{"location":"getting-started/#installation","text":"To install FleetingViews, run pip install fleetingviews To upgrade to the latest version: pip install fleetingviews --upgrade","title":"Installation"},{"location":"getting-started/#import","text":"import FleetingViews as fleetingviews","title":"Import"},{"location":"getting-started/#defining-your-views","text":"Start by defining your views using a simple dictionary structure. Each key is a view name, and its value is a dictionary of view-specific configurations. # View definitions with specific configurations view_definitions = { \"home\" : { \"bgcolor\" : ft . colors . BLUE_GREY , \"vertical_alignment\" : ft . MainAxisAlignment . CENTER , \"horizontal_alignment\" : ft . CrossAxisAlignment . CENTER , }, \"settings\" : { \"bgcolor\" : ft . colors . AMBER_900 , \"vertical_alignment\" : ft . MainAxisAlignment . CENTER , \"horizontal_alignment\" : ft . CrossAxisAlignment . CENTER , }, \"projects\" : { \"bgcolor\" : ft . colors . BLACK , \"vertical_alignment\" : ft . MainAxisAlignment . CENTER , \"horizontal_alignment\" : ft . CrossAxisAlignment . CENTER , }, }","title":"Defining Your Views"},{"location":"getting-started/#notes","text":"This is the most basic example. We'll cover more advanced definitions later on. Any omitted argument will fall back to Flet\u2019s default values. You can declare views in any order, but the first one will be treated as the root view (i.e., the default entry point of your app).","title":"Notes"},{"location":"getting-started/#initializing-fleetingviews","text":"Once you\u2019ve defined your views, create a FleetingViews object: fv = fleetingviews . create_views ( view_definitions = view_definitions , page = page ) That\u2019s it! One line of code and your views are ready.","title":"Initializing FleetingViews"},{"location":"getting-started/#navigating-between-views","text":"To navigate to any registered view, simply use: fv . view_go ( \"name_of_view\" ) For example: fv . view_go ( \"settings\" )","title":"Navigating Between Views"},{"location":"getting-started/#notes_1","text":"You can set history_debug=True as an argument to either view_go() or go_back() to print the navigation flow and see exactly how the history is being handled in your app. fv . view_go ( \"settings\" , history_debug = True ) fv . go_back ( history_debug = True )","title":"Notes:"},{"location":"getting-started/#adding-controls-to-views","text":"FleetingViews supports two convenient methods for adding controls: append() This method adds one or more controls to a specific view: fv . append ( \"view_name\" , controls ) controls can be: * A single Flet control (e.g. ft.Text(\"Hello\") ) * A list of controls (e.g. [ft.Text(\"Hello\"), ft.ElevatedButton(\"Click\")] ) wadd() : A shorthand method to add controls to the currently active working view: fv . wadd ( controls ) This is ideal for building views in sequence without repeating the view name every time. If you want to change the working view (for all future wadd() calls) use: fv . set_working ( \"view_name\" )","title":"Adding controls to views"},{"location":"getting-started/#notes_2","text":"By default, the working view is the last declared view . Use fv.set_working(\"view_name\") to change the active working view for future wadd() calls. Both methods automatically trigger page.update() , so no need to call it manually (you can avoid this behaviour by setting update=False on the arguments!).","title":"Notes"},{"location":"getting-started/#going-back","text":"To return to the previous view: fv . go_back () FleetingViews maintains a history of visited views. Once there's no more history, calling go_back() will return you to the root view. If you want to reset navigation history , use: fv . clean () This clears the navigation stack. The next go_back() will always lead to the root view.","title":"Going back"},{"location":"getting-started/#basic-fleetingviews-design","text":"Here\u2019s a basic conceptual diagram of FleetingViews' routing system: [Root View] \u2193 [View A] \u2190 go_back() \u2193 [View B] \u2190 go_back() \u2193 [View C] \u2190 go_back() Or visually:","title":"Basic FleetingViews design"},{"location":"getting-started/#minimal-working-example","text":"import flet as ft import FleetingViews as fleetingviews def main ( page : ft . Page ): views = { \"home\" : { \"bgcolor\" : ft . colors . BLUE }, \"about\" : { \"bgcolor\" : ft . colors . GREEN }, } fv = fleetingviews . create_views ( view_definitions = views , page = page ) fv . wadd ( ft . Text ( \"Welcome to the home page\" )) fv . set_working ( \"about\" ) fv . wadd ( ft . Text ( \"This is the about page\" )) fv . view_go ( \"home\" ) ft . app ( target = main )","title":"Minimal working example"},{"location":"query_strings/","text":"Query Parameters (v0.1.8) FleetingViews also allows you to pass and use query parameters in your views' URLs. These parameters can be used to store and retrieve dynamic information across different views. Example: Using Query Parameters Let's say you want to pass some parameters like user_id or theme when navigating between views. You can easily achieve this using query strings. Define Your Views with Query Parameters You can use the params argument to pass query parameters. Here's an example of how to use query parameters when navigating to a specific view: # Define views with query parameters in the URL view_definitions = { \"home\" : { \"bgcolor\" : ft . colors . BLUE_GREY , \"vertical_alignment\" : ft . MainAxisAlignment . CENTER , \"horizontal_alignment\" : ft . CrossAxisAlignment . CENTER , }, \"settings\" : { \"bgcolor\" : ft . colors . AMBER_900 , \"vertical_alignment\" : ft . MainAxisAlignment . CENTER , \"horizontal_alignment\" : ft . CrossAxisAlignment . CENTER , }, \"profile\" : { \"bgcolor\" : ft . colors . LIGHT_GREEN , \"vertical_alignment\" : ft . MainAxisAlignment . CENTER , \"horizontal_alignment\" : ft . CrossAxisAlignment . CENTER , }, } # Create views fv = fleetingviews . create_views ( view_definitions = view_definitions , page = page ) # Navigate to 'profile' view with query parameters fv . view_go ( \"profile?user_id=123&theme=dark\" ) Retrieving Query Parameters Once you've navigated to a view with query parameters, you can access those parameters inside your view by using the getters on the FleetingViews instance. # Access query parameters inside the 'profile' view def profile_view ( fv ): user_id = fv . get_param ( \"user_id\" , \"guest\" ) theme = fv . get_param ( \"theme\" , \"light\" ) # Use the parameters in your view print ( f \"User ID: { user_id } \" ) print ( f \"Theme: { theme } \" ) # Add some controls or logic based on the parameters controls = [ ft . Text ( f \"Welcome, { user_id } !\" ), ft . Text ( f \"Theme: { theme } \" ), ] fv . append ( \"profile\" , controls ) Notes You can pass multiple query parameters in the URL by separating them with & . The get_param() method is used to retrieve the parameters. If the parameter does not exist, you can provide a default value. Query parameters are a great way to make your views more dynamic and customizable based on user input or application state. FleetingViews go_back() method remembers not only the page and state, but also the parameters if they were given! Parameters are available as soon as view_go() is triggered, even before guards are evaluated!","title":"Query Parameters"},{"location":"query_strings/#query-parameters-v018","text":"FleetingViews also allows you to pass and use query parameters in your views' URLs. These parameters can be used to store and retrieve dynamic information across different views.","title":"Query Parameters (v0.1.8)"},{"location":"query_strings/#example-using-query-parameters","text":"Let's say you want to pass some parameters like user_id or theme when navigating between views. You can easily achieve this using query strings.","title":"Example: Using Query Parameters"},{"location":"query_strings/#define-your-views-with-query-parameters","text":"You can use the params argument to pass query parameters. Here's an example of how to use query parameters when navigating to a specific view: # Define views with query parameters in the URL view_definitions = { \"home\" : { \"bgcolor\" : ft . colors . BLUE_GREY , \"vertical_alignment\" : ft . MainAxisAlignment . CENTER , \"horizontal_alignment\" : ft . CrossAxisAlignment . CENTER , }, \"settings\" : { \"bgcolor\" : ft . colors . AMBER_900 , \"vertical_alignment\" : ft . MainAxisAlignment . CENTER , \"horizontal_alignment\" : ft . CrossAxisAlignment . CENTER , }, \"profile\" : { \"bgcolor\" : ft . colors . LIGHT_GREEN , \"vertical_alignment\" : ft . MainAxisAlignment . CENTER , \"horizontal_alignment\" : ft . CrossAxisAlignment . CENTER , }, } # Create views fv = fleetingviews . create_views ( view_definitions = view_definitions , page = page ) # Navigate to 'profile' view with query parameters fv . view_go ( \"profile?user_id=123&theme=dark\" )","title":"Define Your Views with Query Parameters"},{"location":"query_strings/#retrieving-query-parameters","text":"Once you've navigated to a view with query parameters, you can access those parameters inside your view by using the getters on the FleetingViews instance. # Access query parameters inside the 'profile' view def profile_view ( fv ): user_id = fv . get_param ( \"user_id\" , \"guest\" ) theme = fv . get_param ( \"theme\" , \"light\" ) # Use the parameters in your view print ( f \"User ID: { user_id } \" ) print ( f \"Theme: { theme } \" ) # Add some controls or logic based on the parameters controls = [ ft . Text ( f \"Welcome, { user_id } !\" ), ft . Text ( f \"Theme: { theme } \" ), ] fv . append ( \"profile\" , controls )","title":"Retrieving Query Parameters"},{"location":"query_strings/#notes","text":"You can pass multiple query parameters in the URL by separating them with & . The get_param() method is used to retrieve the parameters. If the parameter does not exist, you can provide a default value. Query parameters are a great way to make your views more dynamic and customizable based on user input or application state. FleetingViews go_back() method remembers not only the page and state, but also the parameters if they were given! Parameters are available as soon as view_go() is triggered, even before guards are evaluated!","title":"Notes"}]}